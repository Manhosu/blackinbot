import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

// GET - Buscar bot espec√≠fico
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    const cookieStore = cookies();
    const supabaseClient = createRouteHandlerClient({ cookies: () => cookieStore });

    if (!id) {
      return NextResponse.json({
        success: false,
        error: 'ID do bot √© obrigat√≥rio'
      }, { status: 400 });
    }

    console.log(`üîç Buscando bot ${id}...`);

    const { data: bot, error } = await supabaseClient
      .from('bots')
      .select('*')
      .eq('id', id)
      .single();

    if (error) {
      console.error('Erro ao buscar bot:', error);
      return NextResponse.json({
        success: false,
        error: error.message
      }, { status: 404 });
    }

    if (!bot) {
      return NextResponse.json({
        success: false,
        error: 'Bot n√£o encontrado'
      }, { status: 404 });
    }

    console.log(`‚úÖ Bot encontrado: ${bot.name}`);

    return NextResponse.json({
      success: true,
      data: bot
    });

  } catch (error: any) {
    console.error('Erro geral ao buscar bot:', error);
    return NextResponse.json({
      success: false,
      error: 'Erro interno do servidor'
    }, { status: 500 });
  }
}

// PUT - Atualizar bot
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    const body = await request.json();
    const cookieStore = cookies();
    const supabaseClient = createRouteHandlerClient({ cookies: () => cookieStore });

    if (!id) {
      return NextResponse.json({
        success: false,
        error: 'ID do bot √© obrigat√≥rio'
      }, { status: 400 });
    }

    console.log(`üîÑ Atualizando bot ${id}...`);

    // Verificar autentica√ß√£o
    const { data: { user }, error: authError } = await supabaseClient.auth.getUser();
    
    if (authError || !user) {
      console.warn('‚ö†Ô∏è Usu√°rio n√£o autenticado');
      return NextResponse.json({ 
        success: false, 
        error: 'Autentica√ß√£o necess√°ria'
      }, { status: 401 });
    }

    // Campos que podem ser atualizados
    const allowedFields = [
      'name', 
      'description', 
      'webhook_url', 
      'webhook_set_at', 
      'status',
      'is_public'
    ];

    const updateData: any = {};
    allowedFields.forEach(field => {
      if (body[field] !== undefined) {
        updateData[field] = body[field];
      }
    });

    // Adicionar timestamp de atualiza√ß√£o
    updateData.updated_at = new Date().toISOString();

    const { data: updatedBot, error } = await supabaseClient
      .from('bots')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();

    if (error) {
      console.error('Erro ao atualizar bot:', error);
      return NextResponse.json({
        success: false,
        error: error.message
      }, { status: 400 });
    }

    console.log(`‚úÖ Bot atualizado com sucesso: ${updatedBot.name}`);

    return NextResponse.json({
      success: true,
      data: updatedBot,
      message: 'Bot atualizado com sucesso'
    });

  } catch (error: any) {
    console.error('Erro geral ao atualizar bot:', error);
    return NextResponse.json({
      success: false,
      error: 'Erro interno do servidor'
    }, { status: 500 });
  }
}

// DELETE - Excluir bot
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    const cookieStore = cookies();
    const supabaseClient = createRouteHandlerClient({ cookies: () => cookieStore });

    if (!id) {
      return NextResponse.json({
        success: false,
        error: 'ID do bot √© obrigat√≥rio'
      }, { status: 400 });
    }

    console.log(`üóëÔ∏è Excluindo bot ${id}...`);

    // Verificar autentica√ß√£o e obter o usu√°rio
    const { data: { user }, error: authError } = await supabaseClient.auth.getUser();
    
    let userId = null;
    if (authError || !user) {
      console.warn('‚ö†Ô∏è N√£o foi poss√≠vel obter usu√°rio via cookies, tentando acesso direto ao bot...');
      
      // Tentar buscar o bot - se conseguir, √© porque tem acesso via RLS
      const { data: testBot, error: testError } = await supabaseClient
        .from('bots')
        .select('id, name, owner_id')
        .eq('id', id)
        .single();
      
      if (testError || !testBot) {
        console.error('‚ùå Bot n√£o encontrado ou acesso negado:', testError);
        return NextResponse.json({
          success: false,
          error: 'Bot n√£o encontrado ou voc√™ n√£o tem permiss√£o para exclu√≠-lo'
        }, { status: 404 });
      }
      
      userId = testBot.owner_id;
      console.log(`üîç Acesso confirmado ao bot: ${testBot.name} (owner: ${testBot.owner_id})`);
    } else {
      userId = user.id;
      console.log(`üë§ Usu√°rio autenticado: ${user.id}`);
    }

    // Primeiro, verificar se o bot existe e obter todos os dados
    const { data: bot, error: fetchError } = await supabaseClient
      .from('bots')
      .select('*')
      .eq('id', id)
      .single();

    if (fetchError || !bot) {
      console.error('‚ùå Bot n√£o encontrado ou acesso negado:', fetchError);
      return NextResponse.json({
        success: false,
        error: 'Bot n√£o encontrado ou voc√™ n√£o tem permiss√£o para exclu√≠-lo'
      }, { status: 404 });
    }

    console.log(`üîç Bot encontrado: ${bot.name} (owner: ${bot.owner_id})`);

    // Verificar se o usu√°rio √© realmente o dono
    if (bot.owner_id !== userId) {
      console.error(`‚ùå Usu√°rio ${userId} tentou excluir bot de ${bot.owner_id}`);
      return NextResponse.json({
        success: false,
        error: 'Voc√™ n√£o tem permiss√£o para excluir este bot'
      }, { status: 403 });
    }

    // Tentar remover webhook do Telegram antes de excluir
    if (bot.token) {
      try {
        console.log('üîó Removendo webhook do Telegram...');
        const telegramUrl = `https://api.telegram.org/bot${bot.token}/deleteWebhook`;
        const webhookResponse = await fetch(telegramUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ drop_pending_updates: true })
        });
        
        const webhookResult = await webhookResponse.json();
        
        if (webhookResult.ok) {
          console.log('‚úÖ Webhook removido do Telegram');
        } else {
          console.warn('‚ö†Ô∏è Falha ao remover webhook do Telegram:', webhookResult);
        }
      } catch (webhookError) {
        console.warn('‚ö†Ô∏è Erro ao remover webhook (continuando com exclus√£o):', webhookError);
      }
    }

    // Usar RPC para executar as exclus√µes com contexto de autentica√ß√£o adequado
    try {
      console.log('üóëÔ∏è Executando exclus√£o com contexto de autentica√ß√£o...');
      
      const deleteQuery = `
        -- Definir contexto de autentica√ß√£o
        SET LOCAL rls.auth_uid = '${userId}';
        
        -- Remover configura√ß√µes de webhook relacionadas
        DELETE FROM public.webhook_configs WHERE bot_id = '${id}';
        
        -- Remover planos relacionados
        DELETE FROM public.plans WHERE bot_id = '${id}';
        
        -- Excluir o bot
        DELETE FROM public.bots WHERE id = '${id}';
        
        -- Retornar confirma√ß√£o
        SELECT 1 as deleted;
      `;
      
      const { data: deleteResult, error: deleteError } = await supabaseClient.rpc('execute', {
        query: deleteQuery
      });
      
      if (deleteError) {
        console.error('‚ùå Erro ao executar exclus√£o:', deleteError);
        throw new Error(`Erro na exclus√£o: ${deleteError.message}`);
      }
      
      console.log('‚úÖ Exclus√£o executada com sucesso via RPC');
      
    } catch (rpcError: any) {
      console.error('‚ùå Erro na exclus√£o via RPC:', rpcError);
      
      // Fallback: tentar exclus√£o sequencial manual
      console.log('üîÑ Tentando exclus√£o manual sequencial...');
      
      // Remover configura√ß√µes de webhook relacionadas
      try {
        console.log('üóëÔ∏è Removendo configura√ß√µes de webhook...');
        const { error: webhookConfigError } = await supabaseClient
          .from('webhook_configs')
          .delete()
          .eq('bot_id', id);
        
        if (webhookConfigError) {
          console.warn('‚ö†Ô∏è Erro ao remover configura√ß√µes de webhook:', webhookConfigError);
        } else {
          console.log('‚úÖ Configura√ß√µes de webhook removidas');
        }
      } catch (configError) {
        console.warn('‚ö†Ô∏è Erro ao limpar configura√ß√µes:', configError);
      }

      // Remover planos relacionados
      try {
        console.log('üóëÔ∏è Removendo planos relacionados...');
        const { error: plansError } = await supabaseClient
          .from('plans')
          .delete()
          .eq('bot_id', id);
        
        if (plansError) {
          console.warn('‚ö†Ô∏è Erro ao remover planos:', plansError);
        } else {
          console.log('‚úÖ Planos relacionados removidos');
        }
      } catch (plansError) {
        console.warn('‚ö†Ô∏è Erro ao limpar planos:', plansError);
      }

      // Excluir o bot do banco de dados
      console.log('üóëÔ∏è Excluindo bot do banco de dados...');
      const { error: deleteError } = await supabaseClient
        .from('bots')
        .delete()
        .eq('id', id);

      if (deleteError) {
        console.error('‚ùå Erro ao excluir bot do banco:', deleteError);
        return NextResponse.json({
          success: false,
          error: `Erro ao excluir bot: ${deleteError.message}`
        }, { status: 400 });
      }
    }

    console.log(`‚úÖ Bot "${bot.name}" exclu√≠do com sucesso do banco de dados`);

    return NextResponse.json({
      success: true,
      message: `Bot "${bot.name}" exclu√≠do com sucesso`
    });

  } catch (error: any) {
    console.error('‚ùå Erro geral ao excluir bot:', error);
    return NextResponse.json({
      success: false,
      error: `Erro interno do servidor: ${error.message}`
    }, { status: 500 });
  }
}

// PATCH - Atualizar configura√ß√µes personalizadas do bot
export async function PATCH(
  request: Request,
  { params }: { params: { id: string } }
) {
  const cookieStore = cookies();
  const supabaseClient = createRouteHandlerClient({ cookies: () => cookieStore });
  const botId = params.id;
  
  console.log(`üîÑ PATCH /api/bots/${botId}: Atualizando conte√∫do personalizado`);
  
  try {
    // Obter dados da requisi√ß√£o
    const requestData = await request.json();
    console.log('üì¶ Dados recebidos para atualiza√ß√£o parcial:', Object.keys(requestData));
    
    // Estrat√©gia de autentica√ß√£o m√∫ltipla
    let userId = null;
    
    // Estrat√©gia 1: Tentar autentica√ß√£o via cookies
    const { data: { user }, error: authError } = await supabaseClient.auth.getUser();
    
    if (user && !authError) {
      userId = user.id;
      console.log('‚úÖ Usu√°rio autenticado via cookies:', userId);
    } else {
      console.warn('‚ö†Ô∏è Falha na autentica√ß√£o via cookies:', authError?.message || 'Usu√°rio nulo');
      
      // Estrat√©gia 2: Verificar se o bot existe e tem owner_id v√°lido
      const { data: botData, error: botError } = await supabaseClient
        .from('bots')
        .select('id, name, owner_id')
        .eq('id', botId)
        .single();
      
      if (botError || !botData) {
        console.error('‚ùå Bot n√£o encontrado:', botError?.message);
        return NextResponse.json({ 
          success: false, 
          error: 'Bot n√£o encontrado ou acesso negado'
        }, { status: 404 });
      }
      
      // Usar o owner_id do bot como fallback
      userId = botData.owner_id;
      console.log('‚úÖ Usando owner_id do bot como fallback:', userId);
    }
    
    if (!userId) {
      console.error('‚ùå N√£o foi poss√≠vel determinar userId');
      return NextResponse.json({ 
        success: false, 
        error: 'Autentica√ß√£o necess√°ria para atualizar bots'
      }, { status: 401 });
    }
    
    // Campos permitidos para atualiza√ß√£o
    const allowedFields = [
      'name',
      'description', 
      'welcome_message',
      'welcome_media_url',
      'avatar_url',
      'status',
      'is_public'
    ];
    
    // Filtrar apenas campos permitidos
    const updateData: any = {};
    allowedFields.forEach(field => {
      if (requestData[field] !== undefined) {
        updateData[field] = requestData[field];
      }
    });
    
    // Adicionar timestamp de atualiza√ß√£o
    updateData.updated_at = new Date().toISOString();
    
    console.log('üîÑ Atualizando campos:', Object.keys(updateData));
    console.log('üë§ UserId para atualiza√ß√£o:', userId);
    
    // Tentar atualizar no banco de dados usando SQL direto para contornar RLS
    try {
      // Usar fun√ß√£o SQL personalizada para contornar problemas de RLS
      const { data: result, error: rpcError } = await supabaseClient.rpc('update_bot_content', {
        bot_id: botId,
        owner_user_id: userId,
        welcome_msg: updateData.welcome_message || null,
        media_url: updateData.welcome_media_url || null
      });
      
      if (rpcError) {
        console.error('‚ùå Erro na fun√ß√£o RPC:', rpcError.message);
        throw new Error(`Erro ao atualizar via RPC: ${rpcError.message}`);
      }
      
      console.log('‚úÖ Personaliza√ß√£o salva via RPC com sucesso');
      return NextResponse.json({
        success: true,
        bot: result,
        storage: 'database-rpc'
      });
      
    } catch (updateError) {
      console.error('‚ùå Erro ao atualizar:', updateError);
      return NextResponse.json({ 
        success: false, 
        error: 'Erro ao atualizar bot no banco de dados'
      }, { status: 500 });
    }
    
  } catch (error) {
    console.error('‚ùå Erro ao atualizar personaliza√ß√£o do bot:', error);
    return NextResponse.json({ 
      success: false, 
      error: 'Erro ao atualizar personaliza√ß√£o do bot' 
    }, { status: 500 });
  }
} 